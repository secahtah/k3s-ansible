---
# tasks file for k3s-server
#
# This role is executed against the server in order to build it from scratch.
# Some of the operations that install helm charts get executed on the tools 
# server technically since that's where kubectl and helm are installed.  
# Those items will be duly noted here and there will have to be appropriate 
# tags on all of the task.
#
# This role does NOT assume that the first server node has been installed. It
# looks for the "is_first_node" is set; if it is set to "true" then it performs
# the installation on the first node (which other nodes will join later). If it
# is set to "false" it will look for that "first_node_IP_address" variable. 
# NOTE: If "is_first_node" is "false" and "first_node_IP_address" is null, the
# role fails to apply.
#
# This role assumes that the k3s server has at least given an IP address and 
# can reach the internet.
#
# Pass the user as an --extra-var to this playbook if you need to override that
# field.

- name: Bail if they didn't set values correctly
  fail: 
    msg: Override the values of first_node_IP_address and is_first_node
  when: (first_node_IP_address is not defined) and (is_first_node == false)

- name: Detect if k3s is already installed
  ansible.builtin.systemd:
    name: "k3s"
  register: k3s_service_status
  become: true
  ignore_errors: true

# Stuck here, when k3s isn't installed, it fails because I can't compare the key "UnitFileState" 
# https://serverfault.com/questions/857973/is-there-a-way-to-check-that-a-dictionary-key-is-not-defined-in-ansible-task
- name: Set fact if k3s is already installed
  ansible.builtin.set_fact:
    k3s_installed: true
  when: 
    - "'status' in k3s_service_status"
    - "'UnitFileState' in k3s_service_status.status"
    - "k3s_service_status.status.UnitFileState == 'enabled'"

- name: Create folder structure for setup if they don't exist
  file: 
    path: "{{ item }}"
    state: directory
    owner: "{{ remote_user }}"
    group: "{{ remote_user }}"
  loop:
    - "/home/{{ remote_user }}/k3s-setup/certs/client"
    - "/home/{{ remote_user }}/k3s-setup/certs/ca"
    - "/home/{{ remote_user }}/k3s-setup/certs/server"
    - "/home/{{ remote_user }}/k3s-setup/files"
  when: 
    - ((k3s_installed == false) or (force == true))
  tags:
  - k3s_install 

#TODO: Some day, when I have "time," should work on calls to Vault to 
#      generate certs for this. For the k3s substrate however I honestly am fine
#      with a local CA
- name: Copy certs over
  copy:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}"
  loop:
    - src: client.key
      dest: "/home/{{ remote_user }}/k3s-setup/certs/client/client.key"
    - src: client.crt
      dest: "/home/{{ remote_user }}/k3s-setup/certs/client/client.crt"
    - src: ca.crt
      dest: "/home/{{ remote_user }}/k3s-setup/certs/ca/ca.crt"
    - src: server.crt
      dest: "/home/{{ remote_user }}/k3s-setup/certs/server/server.crt"
    - src: k3s-dbclient.key
      dest: "/home/{{ remote_user }}/k3s-setup/certs/client/k3s-dbclient.key"
    - src: k3s-dbclient.crt
      dest: "/home/{{ remote_user }}/k3s-setup/certs/client/k3s-dbclient.crt"
  when: 
    - ((k3s_installed == false) or (force == true))
  tags:
  - k3s_install 

- name: Set IPv4 and IPv6 address variables
  set_fact:
    ipv4_address: "{{ ansible_facts['eth0']['ipv4']['address'] }}"
    ipv6_address: "{{ ansible_facts['eth0']['ipv6'][0]['address'] }}"

- name: Concatenate IPv4 and IPv6 addresses
  set_fact:
    node_cidr: "{{ ipv4_address + ',' + ipv6_address }}"

- name: Run k3s server installer - 1st node
  ansible.builtin.shell: >
    curl -sfL https://get.k3s.io | sh -s - server
    --datastore-endpoint="postgres://k3s:{{ k3s_dbpass | urlquote }}@{{ k3s_dbhost }}:5432/k3s"
    --datastore-cafile="/home/{{ remote_user }}/k3s-setup/certs/ca/ca.crt"
    --token=k3s
    --datastore-certfile="/home/{{ remote_user }}/k3s-setup/certs/client/k3s-dbclient.crt"
    --datastore-keyfile="/home/{{ remote_user }}/k3s-setup/certs/client/k3s-dbclient.key"
    --tls-san="{{ tls_san }}"
    --cluster-cidr={{ cluster_cidr }}
    --service-cidr={{ service_cidr }}
    --node-ip={{ node_cidr }}
    --disable=servicelb
    --disable=traefik
    --https-listen-port={{ https_listen_port }}
  async: 3600
  poll: 10
  environment:
    K3S_KUBECONFIG_MODE: '644'
  tags:
  - k3s_install
  when: 
    - ((first_node_IP_address == "") and (is_first_node == true))
    - ((k3s_installed == false) or (force == true))

- name: Run k3s server installer - nth node
  ansible.builtin.shell: >
    curl -sfL https://get.k3s.io | sh -s - server
    --datastore-endpoint="postgres://{{ k3s_dbuser }}:{{ k3s_dbpass | urlquote }}@{{ k3s_dbhost }}:5432/k3s"
    --datastore-cafile="/home/{{ remote_user }}/k3s-setup/certs/ca/ca.crt"
    --datastore-certfile="/home/{{ remote_user }}/k3s-setup/certs/client/k3s-dbclient.crt"
    --datastore-keyfile="/home/{{ remote_user }}/k3s-setup/certs/client/k3s-dbclient.key"
    --tls-san="{{ tls_san }}"
    --cluster-cidr={{ cluster_cidr }}
    --service-cidr={{ service_cidr }}
    --node-ip={{ node_cidr }}
    --disable=servicelb
    --disable=traefik
    --https-listen-port={{ https_listen_port }}
    --token="{{ k3s_token }}"
  async: 3600
  poll: 10
  environment:
    K3S_KUBECONFIG_MODE: '644'
    # K3S_DBPASS: "1vsgP3u**XgW6Ph5D5Q$"
    # INSTALL_K3S_EXEC: >
    #   --datastore-endpoint="postgres://{{ k3s_dbuser }}:$K3S_DBPASS@{{ k3s_dbhost }}:5432/k3s"
    #   --datastore-cafile="/home/{{ remote_user }}/k3s-setup/certs/ca/ca.crt"
    #   --datastore-certfile="/home/{{ remote_user }}/k3s-setup/certs/client/k3s-dbclient.crt"
    #   --datastore-keyfile="/home/{{ remote_user }}/k3s-setup/certs/client/k3s-dbclient.key"
    #   --tls-san="{{ tls_san }}"
    #   --cluster-cidr={{ cluster_cidr }}
    #   --service-cidr={{ service_cidr }}
    #   --disable=servicelb
    #   --disable=traefik
    #   --https-listen-port={{ https_listen_port }}
    #   --token="{{ k3s_token }}"
  when: 
    - (first_node_IP_address is defined) and (is_first_node == false)
    - ((k3s_installed == false) or (force == true))
  tags:
  - k3s_install

# - name: Install metallb via helm
#   kubernetes.core.helm:
#     host: localhost
#     state: present
#     name:  metallb
#     namespace: kube-system
#     chart:
#       name: stable/metallb
#       source:
#         type: repo
#         location: https://kubernetes-charts.storage.googleapis.com
#     values:
#       configInline:
#         address-pools:
#           - name: default
#             protocol: layer2
#             # FIXME: Move this to a string in "vars"
#             addresses: 192.168.1.128-192.168.1.254
#   when: 
#     - ((k3s_installed == false) or (force == true))
#   tags:
#   - k3s_support


# #- name: Install metallb via helm with the command module
# #  command: >
# #    helm install metallb stable/metallb --namespace kube-system 
# #    --set configInline.address-pools[0].name=default 
# #    --set configInline.address-pools[0].protocol=layer2 
# #    --set configInline.address-pools[0].addresses[0]=192.168.1.128-192.168.1.254

# - name: Download the custom resource definition for cert manager
#   get_url:
#     url: https://raw.githubusercontent.com/jetstack/cert-manager/release-0.14/deploy/manifests/00-crds.yaml
#     dest: /tmp/00-crds.yaml
#     mode: '0777'
#   when: 
#     - ((k3s_installed == false) or (force == true))
#   tags:
#   - k3s_support

# - name: Install custom resource definition for cert manager
#   #? can this be done via the k8s module?  Not clear if that's just kubectl under the hood
#   # looks like it can, trying that out - 
#   # kubectl apply --validate=false -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.14/deploy/manifests/00-crds.yaml
#   k8s:
#     state: present
#     api_version: v1
#     apply: yes
#     validate:
#       fail_on_error: yes
#       strict: no
#     resource_definition: "{{ lookup('file', '/tmp/00-crds.yaml ')}}"
#   when: 
#     - ((k3s_installed == false) or (force == true))
#   tags:
#   - k3s_support

# - name: Add jetstack repo to helm and update all helm repos
#   # going to do this via the command module until a better way is found
#   command: helm repo add jetstack https://charts.jetstack.io && helm repo update
#   when: 
#     - ((k3s_installed == false) or (force == true))
#   tags:
#   - k3s_support

# - name: Install cert-manager into the kube-system namespace 
#   # goign to do this via the command module until a better way is found
#   command: helm install cert-manager jetstack/cert-manager --namespace kube-system
#   when: 
#     - ((k3s_installed == false) or (force == true))
#   tags:
#   - k3s_support

# - name: Configure lets-encrypt staging certificate issues
#   k8s:
#     state: present
#     src: "../../{{ user }}/cert-issuer-stage.yml"
#   when: 
#     - ((k3s_installed == false) or (force == true))
#   tags:
#   - k3s_support

# - name: Configure lets-encrypt prod certificate issues
#   k8s:
#     state: present
#     src: "../../{{ user }}/cert-issuer-prod.yml"
#   when: 
#     - ((k3s_installed == false) or (force == true))
#   tags:
#   - k3s_support

# - name: Install the K8s dashboard
#   # Note, the guide only walks you through using kube proxy to access the dashboard which restricts
#   # the allowed source to localhost by design.  Need to investigate how to securely expose the dashboard
#   # via a service for the purposes of the install script in order to be able to access the dashboard
#   # from anywhere.
#   debug:
#     msg: "If we got this far, something is jacked"
#   when: 
#     - ((k3s_installed == false) or (force == true))
#   tags:
#   - k3s_support
  